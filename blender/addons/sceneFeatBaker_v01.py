# Baking scene object into OSL script for later use in material nodes

# Used resources:
# https://blender.stackexchange.com/questions/27491/python-vertex-normal-according-to-world
import bpy
import bmesh
import math
import mathutils
from mathutils import Vector
from random import random, seed
from bpy_extras import view3d_utils
from bpy_extras.object_utils import world_to_camera_view

from bpy.props import (StringProperty,
						BoolProperty,
						IntProperty,
						FloatProperty,
						FloatVectorProperty,
						EnumProperty,
						PointerProperty,
						)
from bpy.types import (Panel,
						Operator,
						AddonPreferences,
						PropertyGroup,
						)

bl_info = {
	"name": "WPL Scene 2 Osl",
	"author": "IPv6",
	"version": (1, 0),
	"blender": (2, 78, 0),
	"location": "View3D > T-panel > WPL",
	"description" : "",
	"warning"	 : "",
	"wiki_url"	: "",
	"tracker_url" : "",
	"category"	: ""
	}

class wplscene_bake2osl( bpy.types.Operator ):
	bl_idname = "object.wplscene_bake2osl"
	bl_label = "Bake scene into OSL script"
	bl_options = {'REGISTER', 'UNDO'}

	@classmethod
	def poll( cls, context ):
		return True

	def execute( self, context ):
		bakeOpts = context.scene.wplScene2OslSettings
		if len(bakeOpts.oslScriptName) < 3:
			self.report({'ERROR'}, "Invalid script name")
			return {'CANCELLED'}

		objs2dump = [obj for obj in bpy.data.objects if len(bakeOpts.objNameSubstr) == 0 or obj.name.find(bakeOpts.objNameSubstr) >= 0]
		print("objs2dump",objs2dump)

		objsData = []
		for obj in objs2dump:
			item = {}
			g_loc = obj.matrix_world.to_translation() # * obj.location
			mx_inv = obj.matrix_world.inverted()
			mx_norm = mx_inv.transposed().to_3x3()
			g_locx = mx_norm * Vector((1,0,0))
			g_locy = mx_norm * Vector((0,1,0))
			g_locz = mx_norm * Vector((0,0,1))
			item["name"] = "\""+obj.name+"\""
			item["location"] = "point("+repr(g_loc[0])+","+repr(g_loc[1])+","+repr(g_loc[2])+")"
			item["normx"] = "point("+repr(g_locx[0])+","+repr(g_locx[1])+","+repr(g_locx[2])+")"
			item["normy"] = "point("+repr(g_locy[0])+","+repr(g_locy[1])+","+repr(g_locy[2])+")"
			item["normz"] = "point("+repr(g_locz[0])+","+repr(g_locz[1])+","+repr(g_locz[2])+")"
			#item["rotation"] = "point("+repr(obj.rotation_euler[0])+","+repr(obj.rotation_euler[1])+","+repr(obj.rotation_euler[2])+")"
			item["scale"] = "point("+repr(obj.scale[0])+","+repr(obj.scale[1])+","+repr(obj.scale[2])+")"
			item["dims"] = "point("+repr(obj.dimensions[0])+","+repr(obj.dimensions[1])+","+repr(obj.dimensions[2])+")"
			bbc = [obj.matrix_world * Vector(corner) for corner in obj.bound_box]
			item["bbmin"] = "point("+repr(min(item[0] for item in bbc))+","+repr(min(item[1] for item in bbc))+","+repr(min(item[2] for item in bbc))+")"
			item["bbmax"] = "point("+repr(max(item[0] for item in bbc))+","+repr(max(item[1] for item in bbc))+","+repr(max(item[2] for item in bbc))+")"
			objsData.append(item)
		objsData = sorted(objsData, key=lambda k: k['name'])

		textblock = bpy.data.texts.get(bakeOpts.oslScriptName)
		if not textblock:
			textblock = bpy.data.texts.new(bakeOpts.oslScriptName)
		else:
			textblock.clear()
		osl_content = []
		osl_content.append("// WARNING: text below is autogenerated, DO NOT EDIT.")
		osl_content.append("#define DUMPLEN "+str(len(objsData)))
		#osl_content.append("#define ZEROP point(0,0,0)")
		osl_content.append("shader sceneQuery (")
		osl_content.append(" float maxDistance = 0,")
		osl_content.append(" string by_name_equality = \"\",")
		osl_content.append(" string by_near_startswith = \"\",")
		osl_content.append(" output float objectNum = 0,")
		osl_content.append(" output point g_Location = point(0,0,0),")
		osl_content.append(" output point normalX = point(0,0,0),")
		osl_content.append(" output point normalY = point(0,0,0),")
		osl_content.append(" output point normalZ = point(0,0,0),")
		osl_content.append(" output point scale = point(0,0,0),")
		osl_content.append(" output point dimensions = point(0,0,0),")
		osl_content.append(" output point g_boundsMax = point(0,0,0),")
		osl_content.append(" output point g_boundsMin = point(0,0,0),")
		osl_content.append("){")
		osl_content.append(" string sceneNames[DUMPLEN] = {"+",".join([ item['name'] for item in objsData ])+"};")
		osl_content.append(" point sceneLocas[DUMPLEN] = {"+",".join([ item['location'] for item in objsData ])+"};")
		osl_content.append(" point sceneScales[DUMPLEN] = {"+",".join([ item['scale'] for item in objsData ])+"};")
		osl_content.append(" point sceneNormalX[DUMPLEN] = {"+",".join([ item['normx'] for item in objsData ])+"};")
		osl_content.append(" point sceneNormalY[DUMPLEN] = {"+",".join([ item['normy'] for item in objsData ])+"};")
		osl_content.append(" point sceneNormalZ[DUMPLEN] = {"+",".join([ item['normz'] for item in objsData ])+"};")
		osl_content.append(" point sceneDimens[DUMPLEN] = {"+",".join([ item['dims'] for item in objsData ])+"};")
		osl_content.append(" point sceneBbmax[DUMPLEN] = {"+",".join([ item['bbmax'] for item in objsData ])+"};")
		osl_content.append(" point sceneBbmin[DUMPLEN] = {"+",".join([ item['bbmin'] for item in objsData ])+"};")
		osl_content.append(" if(strlen(by_name_equality)>0){")
		osl_content.append("  for(int i=0;i<DUMPLEN;i++){")
		osl_content.append("   if(sceneNames[i] == by_name_equality){")
		osl_content.append("	if(maxDistance>0 && length(P-sceneLocas[i])>maxDistance){")
		osl_content.append("	 continue;")
		osl_content.append("	}")
		osl_content.append("	objectNum = i+1;")
		osl_content.append("	g_Location = sceneLocas[i];")
		osl_content.append("	scale = sceneScales[i];")
		osl_content.append("	normalX = sceneNormalX[i];")
		osl_content.append("	normalY = sceneNormalY[i];")
		osl_content.append("	normalZ = sceneNormalZ[i];")
		osl_content.append("	dimensions = sceneDimens[i];")
		osl_content.append("	g_boundsMax = sceneBbmax[i];")
		osl_content.append("	g_boundsMin = sceneBbmin[i];")
		osl_content.append("	return;")
		osl_content.append("   }")
		osl_content.append("  }")
		osl_content.append(" }")
		osl_content.append(" if(strlen(by_near_startswith)>0){")
		osl_content.append("  int iNearesIdx = -1;")
		osl_content.append("  float iNearesDist = 99999.0;")
		osl_content.append("  for(int i=0;i<DUMPLEN;i++){")
		osl_content.append("   if(startswith(sceneNames[i],by_near_startswith)>0){")
		osl_content.append("	float dist = length(P-sceneLocas[i]);")
		osl_content.append("	if(maxDistance>0 && length(P-sceneLocas[i])>maxDistance){")
		osl_content.append("	 continue;")
		osl_content.append("	}")
		osl_content.append("	if(dist<iNearesDist){")
		osl_content.append("	 iNearesDist = dist;")
		osl_content.append("	 iNearesIdx = i;")
		osl_content.append("	}")
		osl_content.append("   }")
		osl_content.append("  }")
		osl_content.append("  if(iNearesIdx >= 0){")
		osl_content.append("   int i = iNearesIdx;")
		osl_content.append("   objectNum = i+1;")
		osl_content.append("   g_Location = sceneLocas[i];")
		osl_content.append("   scale = sceneScales[i];")
		osl_content.append("   normalX = sceneNormalX[i];")
		osl_content.append("   normalY = sceneNormalY[i];")
		osl_content.append("   normalZ = sceneNormalZ[i];")
		osl_content.append("   dimensions = sceneDimens[i];")
		osl_content.append("   g_boundsMax = sceneBbmax[i];")
		osl_content.append("   g_boundsMin = sceneBbmin[i];")
		osl_content.append("   return;")
		osl_content.append("  }")
		osl_content.append(" }")
		osl_content.append("}")
		textblock.write("\n".join(osl_content))

		self.report({'INFO'}, "Scene baked successfully")
		return {'FINISHED'}


class wplscene_dedupmats( bpy.types.Operator ):
	bl_idname = "object.wplscene_dedupmats"
	bl_label = "Replace Material-dupes with originals"
	bl_options = {'REGISTER', 'UNDO'}

	@classmethod
	def poll( cls, context ):
		return True

	def execute( self, context ):
		mats = bpy.data.materials
		for obj in bpy.data.objects:
			for slt in obj.material_slots:
				part = slt.name.rpartition('.')
				if part[2].isnumeric() and part[0] in mats:
					print("  Replace '%s' with '%s'" % (slt.name, part[0]))
					slt.material = mats.get(part[0])

		self.report({'INFO'}, "Materials deduped")
		return {'FINISHED'}

class wplscene_dedupnods( bpy.types.Operator ):
	bl_idname = "object.wplscene_dedupnods"
	bl_label = "Replace NodeGroup-dupes with originals"
	bl_options = {'REGISTER', 'UNDO'}

	@classmethod
	def poll( cls, context ):
		return True

	def dump(self,obj):
		for attr in dir(obj):
			if hasattr( obj, attr ):
				print( "obj.%s = %s" % (attr, getattr(obj, attr)))

	def eliminateNG(self, node):
		node_groups = bpy.data.node_groups
		
		# Get the node group name as 3-tuple (base, separator, extension)
		(base, sep, ext) = node.node_tree.name.rpartition('.')

		# Replace the numeric duplicate
		if ext.isnumeric():
			if base in node_groups:
				print("- Replace nodegroup '%s' with '%s'" % (node.node_tree.name, base))
				node.node_tree.use_fake_user = False
				node.node_tree = node_groups.get(base)

	def eliminateSN(self, node):
		#print("Checking ",node.name,node.script)
		oldscript = node.script
		if oldscript is not None:
			(base, sep, ext) = oldscript.name.rpartition('.')
			# Replace the numeric duplicate
			if ext.isnumeric():
				if base in bpy.data.texts:
					print("- Replace script '%s' with '%s'" % (oldscript.name, base))
					node.script = bpy.data.texts.get(base)
					#postTextblocksCleanup.append(oldscript)
					node.update()
		
	def execute( self, context ):
		#--- Search for duplicates in actual node groups
		node_groups = bpy.data.node_groups
		for group in node_groups:
			for node in group.nodes:
				if node.bl_idname == 'ShaderNodeScript':
					self.eliminateSN(node)
				elif node.type == 'GROUP':
					self.eliminateNG(node)

		#--- Search for duplicates in materials
		mats = list(bpy.data.materials)
		worlds = list(bpy.data.worlds)

		for mat in mats + worlds:
			if mat.use_nodes:
				for node in mat.node_tree.nodes:
					if node.bl_idname == 'ShaderNodeScript':
						self.eliminateSN(node)
					elif node.type == 'GROUP':
						self.eliminateNG(node)

		allTexts = bpy.data.texts.keys()
		for scriptname in allTexts:
			(base, sep, ext) = scriptname.rpartition('.')
			if ext.isnumeric():
				if base in bpy.data.texts:
					print("- Text cleanup: Removing ", scriptname)
					bpy.data.texts.remove(bpy.data.texts.get(scriptname))
		self.report({'INFO'}, "NodeGroups deduped")
		return {'FINISHED'}

class wplscene_swtstate( bpy.types.Operator ):
	bl_idname = "object.wplscene_swtstate"
	bl_label = "Switch scene state"
	bl_options = {'REGISTER', 'UNDO'}

	@classmethod
	def poll( cls, context ):
		return True

	def updateObjShapekeys( self, context, obj ):
		try:
			if (obj.data is None) or (obj.data.shape_keys is None) or (obj.data.shape_keys.key_blocks is None):
				return
		except:
			return
		bakeOpts = context.scene.wplScene2OslSettings
		keys = obj.data.shape_keys.key_blocks.keys()
		active_idx = 0
		for kk in keys:
			if kk.find(bakeOpts.scnStateCommon) >= 0:
				if kk.find(bakeOpts.scnStateId) >= 0:
					shape_key = obj.data.shape_keys.key_blocks[kk]
					obj.active_shape_key_index = keys.index(kk)
					active_idx = obj.active_shape_key_index
					shape_key.value = 1
				else:
					shape_key = obj.data.shape_keys.key_blocks[kk]
					obj.active_shape_key_index = keys.index(kk)
					shape_key.value = 0
		obj.active_shape_key_index = active_idx
		obj.data.update()

	def updateObjPose( self, context, obj ):
		# https://blenderartists.org/forum/showthread.php?254069-Activate-A-Pose-Library-Entry-via-Python-Code
		def isKeyOnFrame(passedFcurve, passedFrame):
			result = False
			for k in passedFcurve.keyframe_points:
				if int(k.co.x) == int(passedFrame):
					result = True
					break
			return result
		try:
			if (obj.pose is None) or (obj.pose_library is None) or (obj.pose_library.pose_markers is None):
				return
		except:
			return
		bakeOpts = context.scene.wplScene2OslSettings
		pl = obj.pose_library
		p = obj.pose
		keys = obj.pose_library.pose_markers.keys()
		for kk in keys:
			if kk.find(bakeOpts.scnStateCommon) >= 0:
				if kk.find(bakeOpts.scnStateId) >= 0:
					pm = pl.pose_markers[kk]
					frame = pm.frame
					action = bpy.data.actions[pl.name]
					for agrp in action.groups:
						# check if group has any keyframes.
						for fc in agrp.channels:
							r = isKeyOnFrame(fc,frame)
							if r == True:
								tmpValue = fc.evaluate(frame)
								i = p.bones.find(agrp.name)
								if i != -1:
									pb = p.bones[i]
									if fc.data_path.find("location") != -1:
										pb.location[fc.array_index] = tmpValue
									if fc.data_path.find("rotation_quaternion") != -1:
										pb.rotation_quaternion[fc.array_index] = tmpValue
									if fc.data_path.find("rotation_euler") != -1:
										pb.rotation_euler[fc.array_index] = tmpValue
									if fc.data_path.find("scale") != -1:
										pb.scale[fc.array_index] = tmpValue

	def execute( self, context ):
		bakeOpts = context.scene.wplScene2OslSettings
		if len(bakeOpts.scnStateCommon) < 1:
			self.report({'ERROR'}, "Invalid common name")
			return {'CANCELLED'}

		objs2check = [obj for obj in bpy.data.objects]
		for obj in objs2check:
			if obj.name.find(bakeOpts.scnStateCommon) >= 0:
				if obj.name.find(bakeOpts.scnStateId) >= 0:
					obj.hide = False
					obj.hide_render = False
				else:
					obj.hide = True
					obj.hide_render = True
		for obj in objs2check:
			self.updateObjPose(context, obj)
			self.updateObjShapekeys(context, obj)

		self.report({'INFO'}, "Scene state switched")
		return {'FINISHED'}

class WPLScene2OslSettings(PropertyGroup):
	oslScriptName = bpy.props.StringProperty(
		name		= "OSL script name",
		default	 = "_sceneQuery.osl"
		)
	objNameSubstr = bpy.props.StringProperty(
		name		= "Part of object name",
		description = "Part of name, other objects will not be baked",
		default	 = "_osl"
		)

	scnStateCommon = bpy.props.StringProperty(
		name		= "Prefix of state",
		description = "Objname/Shapekeys common namepart",
		default	 = "##"
		)
	scnStateId = bpy.props.StringProperty(
		name		= "ID of state",
		description = "Objname/Shapekeys state namepart",
		default	 = "0"
		)

class WPLScene2Osl_Panel(bpy.types.Panel):
	bl_label = "Scene 2 Osl"
	bl_space_type = 'VIEW_3D'
	bl_region_type = 'TOOLS'
	bl_context = "objectmode"
	bl_category = 'WPL'

	def draw_header(self, context):
		layout = self.layout
		layout.label(text="")

	def draw(self, context):
		layout = self.layout
		bakeOpts = context.scene.wplScene2OslSettings

		# display the properties
		col = layout.column()
		col.prop(bakeOpts, "oslScriptName")
		col.prop(bakeOpts, "objNameSubstr")
		col.operator("object.wplscene_bake2osl", text="Bake scene -> OSL")

		col.separator()
		row = col.row()
		row.prop(bakeOpts, "scnStateCommon")
		row.prop(bakeOpts, "scnStateId")
		col.operator("object.wplscene_swtstate", text="Switch scene state")

		col.separator()
		col.operator("object.wplscene_dedupnods", text="Dedupe NodeGroups")
		col.operator("object.wplscene_dedupmats", text="Dedupe Materials")

def register():
	print("WPLScene2Osl_Panel registered")
	bpy.utils.register_module(__name__)
	bpy.types.Scene.wplScene2OslSettings = PointerProperty(type=WPLScene2OslSettings)

def unregister():
	del bpy.types.Scene.wplScene2OslSettings
	bpy.utils.unregister_module(__name__)

if __name__ == "__main__":
	register()
